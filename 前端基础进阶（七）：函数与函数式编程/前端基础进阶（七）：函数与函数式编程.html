<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>

</body>
<script>
    /*
    * 函数表达式的应用场景
    * */
/*    //在构造函数中添加方法
    function Person(name) {
        this.name = name;
        this.age = age;
        // 在构造函数内部中添加方法
        this.getAge = function() {
            return this.age;
        }
        this.
    }
    // 给原型添加方法
    Person.prototype.getName = function() {
        return this.name;
    }

    // 在对象中添加方法
    var a = {
        m: 20,
        getM: function() {
            return this.m;
        }
    }*/
    /*
    * 匿名函数：没有显示而被赋值运行的流程解析
    * */
  /*  var a = 10;
    var fn = function(bar, num) {
        return bar() + num;
    }

    fn(function() {
        return a;
    }, 20)


   // 变量对象在fn上下文执行过程中的创建阶段
   VO(fn) = {
   arguments: {
   bar: undefined,
   num: undefined,
   length: 2
   }
   }
    //解析过程
   // 变量对象在fn上下文执行过程中的执行阶段
   // 变量对象变为活动对象，并完成赋值操作与执行可执行代码
   VO -> AO

   AO(fn) = {
   arguments: {
   bar: function() { return a },
   num: 20,
   length: 2
   }
   }
    */
    /*
    *
    * 块级作用域与自运行函数
    * 块级作用域理解为多个函数作用于一个作用域下
    * */
    /*(function() {
        // ...
    })();*/
    /*
    * 作用域的单向访问，从而形成私有属性和私有变量
    * */
  /*  (function() {
        // 私有变量
        var age = 20;
        var name = 'Tom';

        // 私有方法
        function getName() {
            return `your name is ` + name;
        }
    })();*/
    /*
    * 闭包形成共有属性和共有方法
    * */
    /*(function() {
        // 私有变量
        var age = 20;
        var name = 'Tom';


        // 私有方法
        function getName() {
            return `your name is ` + name;
        }


        // 共有方法
        function getAge() {
            return age;
        }

        // 将引用保存在外部执行环境的变量中，形成闭包，防止该执行环境被垃圾回收
        window.getAge = getAge;
    })();*/

    /*
    * jquery中的模块和闭包的使用
    * */
   /*
    // 使用函数自执行的方式创建模块
    (function(window, undefined) {

        // 声明jQuery构造函数
        var jQuery = function(name) {

            // 主动在构造函数中，返回一个jQuery实例
            return new jQuery.fn.init(name);
        }

        // 添加原型方法
        jQuery.prototype = jQuery.fn = {
            constructor: jQuery,
            init:function() { ... },
            css: function() { ... }
        }
        jQuery.fn.init.prototype = jQuery.fn;

        // 将jQuery改名为$，并将引用保存在window上，形成闭包，对外开发jQuery构造函数，这样我们就可以访问所有挂载在jQuery原型上的方法了
        window.jQuery = window.$ = jQuery;
    })(window);

    // 在使用时，我们直接执行了构造函数，因为在jQuery的构造函数中通过一些手段，返回的是jQuery的实例，所以我们就不用再每次用的时候在自己new了
    $('#div1');*/

    /*
    * redux状态管理的实现原理
    * */

   /* // 自执行创建模块
    (function() {
        // states 结构预览
        // states = {
        //     a: 1,
        //     b: 2,
        //     m: 30,
        //     o: {}
        // }
        var states = {};  // 私有变量，用来存储状态与数据

        // 判断数据类型
        function type(elem) {
            if(elem == null) {
                return elem + '';
            }
            return toString.call(elem).replace(/[\[\]]/g, '').split(' ')[1].toLowerCase();
        }


        /!**
         * @Param name 属性名
         * @Description 通过属性名获取保存在states中的值
         *!/
        function get(name) {
            return states[name] ? states[name] : '';
        }

        function getStates() {
            return states;
        }

        /!*
         * @param options {object} 键值对
         * @param target {object} 属性值为对象的属性，只在函数实现时递归中传入
         * @desc 通过传入键值对的方式修改state树，使用方式与小程序的data或者react中的setStates类似
         *!/
        function set(options, target) {
            var keys = Object.keys(options);
            var o = target ? target : states;

            keys.map(function(item) {
                if(typeof o[item] == 'undefined') {
                    o[item] = options[item];
                }
                else {
                    type(o[item]) == 'object' ? set(options[item], o[item]) : o[item] = options[item];
                }
                return item;
            })
        }

        // 对外提供接口
        window.get = get;
        window.set = set;
        window.getStates = getStates;
    })()

    // 具体使用如下

    set({ a: 20 });     // 保存 属性a
    set({ b: 100 });    // 保存属性b
    set({ c: 10 });     // 保存属性c

    // 保存属性o, 它的值为一个对象
    set({
        o: {
            m: 10,
            n: 20
        }
    })

    // 修改对象o 的m值
    set({
        o: {
            m: 1000
        }
    })

    // 给对象o中增加一个c属性
    set({
        o: {
            c: 100
        }
    })
    console.log(getStates())*/
    /*
    *
    * 正常的基本数据和引用类型数据按值传递
    * */
  /*  var a = 20;
    var b = a;
    b = 10;
    console.log(a);  // 20

    var m = { a: 1, b: 2 }
    var n = m;
    n.a = 5;
    console.log(m.a) // 5*/
    /*
    * 以函数参数为值得按值传递
    * */
   /* var a = 20;
    function fn(a) {
        a = a + 10;//这里的a是创建在变量对象的a,如果没有接受，会被销毁
        return a;
    }
    fn(a);
    console.log(a); // 20
    console.log(fn(a));

    var a = { m: 10, n: 20 };
    function fn(a) {
        a.m = 20;
        return a;
    }

    fn(a);
    console.log(a);   // { m: 20, n: 20 }
    console.log(fn(a))*/

    /*
    * 引用类型按值传递全面解析，引用地址的复制传递
    * */
    /*var person = {
        name: 'Nicholas',
        age: 20
    }
    function setName(obj) {  // 传入一个引用
        obj = {};   // 将传入的引用指向另外的值
        obj.name = 'Greg';  // 修改引用的name属性
    }
    setName(person);
    console.log(person.name);  // Nicholas 未被改变*/

    /*
    * 函数式当做变量的混合应用
    * 函数只用"表达式"，不用"语句"
    * */
    /*var a = function foo() {}  // 赋值
    function fn(function() {}, num) {}   // 函数作为参数

    // 函数作为返回值
    function var() {
        return function() {
            ... ...
        }
    }*/
    /*
    * 普通封装
    * */
    /*function add(num1, num2) {
        return num1 + num2;
    }

    add(20, 10); // 30*/

    /*
    * 挂载在对象上的封装
    * */
   /* if(typeof Array.prototype.add !== 'function') {
        Array.prototype.add = function() {
            var i = 0,
                    len = this.length,
                    result = 0;

            for( ; i < len; i++) {
                result += this[i]
            }
            return result;
        }
    }

    [1, 2, 3, 4].add() // 10*/
</script>
</html>