<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>

</body>
<script>
    /*
    * 用执行上下文的创建变量对象来解释变量提升这一过程
    *
    * */
   /* // demo01
    function test() {
        console.log(a);
        console.log(foo());
        var a = 1;
        function foo() {
            return 2;
        }
    }
    test();*/
    创建过程
    testEC = {
        // 变量对象
        VO: {},
        scopeChain: {},
        this: {}
    }
        /*
        * 执行上下文中创建变量对象的过程详情
        * */
/*    // 因为本文暂时不详细解释作用域链和this，所以把变量对象专门提出来说明
    // VO 为 Variable Object的缩写，即变量对象
    VO = {
            arguments: {...},  //注：在浏览器的展示中，函数的参数可能并不是放在arguments对象中，这里为了方便理解，我做了这样的处理
            foo: <foo reference>  // 表示foo的地址引用
            a: undefined
        }*/
    /*
    * 执行上下文的执行阶段的过程详情
    * */
   /* // 执行阶段
    VO ->  AO   // Active Object
    AO = {
            arguments: {...},
            foo: <foo reference>,
            a: 1
    }
    function test() {
    function foo() {
    return 2;
    }
    var a;
    console.log(a);
    console.log(foo());
    a = 1;
    }
    test();
    */
    /*
    * demo2
    * */
/*    // demo2
    function test() {
        console.log(foo);
        console.log(bar);

        var foo = 'Hello';
        console.log(foo);
        var bar = function () {
            return 'world';
        }

        function foo() {
            return 'hello';
        }
    }
    test();
    // 创建阶段
    VO = {
        arguments: {...},
            foo: <foo reference>,
            bar: undefined
    }
    // 这里有一个需要注意的地方，因为var声明的变量当遇到同名的属性时，会跳过而不会覆盖
    // 执行阶段
    VO -> AO
    VO = {
        arguments: {...},
            foo: 'Hello',
            bar: <bar reference>
    }*/
    /*
    * 全局上下文window
    * */
   /* // 以浏览器中为例，全局对象为window
    // 全局上下文
    windowEC = {
        VO: window,
        scopeChain: {},
        this: window
    }*/
</script>
</html>